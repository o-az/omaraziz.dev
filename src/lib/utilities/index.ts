import { devLogger } from './logger';
export { devLogger };
import type { JSX } from 'solid-js';

export const randomArrayElement = <T>(array: T[]): T => array[Math.floor(Math.random() * array.length)] as T;

export function loadExternalScript(args: {
  script: string | HTMLScriptElement;
  devEnabled?: boolean;
  parentElement: keyof JSX.IntrinsicElements;
}) {
  const { script, devEnabled, parentElement } = args;
  if (import.meta.env.DEV && !devEnabled) return;
  setTimeout(() => {
    const element = document.querySelector(parentElement);
    if (!element) return devLogger([loadExternalScript.name, `Could not find element ${parentElement}`]);
    const range = document.createRange();
    const scriptFragment = typeof script === 'string' ? script : script.outerHTML;
    const fragment = range.createContextualFragment(scriptFragment);
    element.appendChild(fragment);
  }, 1000);
}

/**
 * Anchor elements generated by MDX don't have a target attribute.
 * This adds "_blank" to the target attribute if the href is external and
 * "_self" if the href is internal. "_self" helps scroll to the proper heading.
 */
export function addAnchorsTarget(timeout = 1000) {
  /** Helper for applyTargetAttribute */
  const addAnchorTarget = (anchor: HTMLAnchorElement) => {
    const target = anchor.getAttribute('target');
    if (target) return;
    const href = anchor.getAttribute('href');
    if (!href) return;
    href.startsWith('http')
      ? anchor.setAttribute('target', '_blank')
      : href.startsWith('#')
      ? anchor.setAttribute('target', '_self')
      : null;
  };

  try {
    setTimeout(() => {
      const anchors = document.querySelectorAll('a[href^="#"]');
      anchors.forEach(addAnchorTarget);
    }, timeout);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : `Encoutered an error: ` + error;
    devLogger([addAnchorTarget.name, errorMessage]);
  }
}

export const removeFalsy = <T>(object: T): NonNullable<T> => JSON.parse(JSON.stringify(object));

export const ArrayToChunks = (array: Array<string>, chunkSize: number): Array<string>[] => {
  const items = new Array(Math.ceil(array.length / chunkSize));
  return items.fill(0).map(() => array.splice(0, chunkSize));
};

export const getTimestamp = () => {
  const [timestamp] = new Date().toISOString().split('T');
  return timestamp;
};

export const nonNullable = <T>(value: T): value is NonNullable<T> => value !== null && value !== undefined;

export const dateStringToHuman = (date: string) => {
  const datifiedDate = new Date(date);
  const options: Intl.DateTimeFormatOptions = { month: 'long', day: 'numeric', year: 'numeric' };
  return new Intl.DateTimeFormat('en-US', options).format(datifiedDate);
};
